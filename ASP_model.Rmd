# Handling ASP model

The answers from ASP are saved in the .txt format. We import into R to perform visualization and filtering incomplete models.

## Import answers file

```{r import answer file}
BN_file <- read.table(file = "./answers_ThModel_constraint_2", 
                      header = FALSE, 
                      stringsAsFactors = FALSE,
                      skip = 3, 
                      sep = '\n')
BN_file<-BN_file[1:(dim(BN_file)[1]-5),]
BN_file <- BN_file[c(FALSE,TRUE)]
BN_list <- strsplit(BN_file, split = ' ')
BN_table <- unlist(BN_list)
BN_table <- table(BN_table)
View(BN_table/length(BN_file))
```

We can see the ratio of each interaction from all model.

We then covert the list of interactions in each answers into table to visualize the content

## Convert interaction list to interaction table

```{r convert interaction list to interaction table}
model_link <-rownames(BN_table)
test<-c()
table<-c()
for(x in 1:length(model_link)){
  for(i in 1:length(BN_list)){
    a<-model_link[x]%in%BN_list[[i]]
    test <- c(test,a)
  }
  table <- cbind(table,test)
  test<-c()
}
colnames(table)<- model_link
for(i in 1:ncol(table)){
  table[,i] <- as.numeric(table[,i])
}
head(table)
#heatmap(as.matrix(table), cexCol = 0.4, cexRow = 0.1)
```

From the heatmap, we can see that several model have constant and variable interaction. We believe this variable interaction is the crucial components that give rise to the dynamics according to given constraints.

We apply the graph constraint to filter the model with incomplete components/interactions.

## Filter by graph contraints

This process still rely on manual selection of the constraints. We are currently working on defining of graph constraint and the implementation of automatic constraint selection.

```{r filtering model the model with constant}
filter_table <- table[table[,27]==0,]
filter_table <- filter_table[filter_table[,28]==0,]
filter_table <- filter_table[filter_table[,30]==0,]
filter_table <- filter_table[filter_table[,31]==0,]
filter_table <- filter_table[filter_table[,32]==0,]
dim(filter_table)
#heatmap(as.matrix(filter_table),cexCol = 0.4,cexRow = 0.1)
```

```{r filtering model from the interaction}
filter_table <- filter_table[filter_table[,1]==1,]
filter_table <- filter_table[filter_table[,2]==1,]
filter_table <- filter_table[filter_table[,3]==1,]
filter_table <- filter_table[filter_table[,6]==1,]
filter_table <- filter_table[filter_table[,7]==1,]
filter_table <- filter_table[filter_table[,8]==1,]
filter_table <- filter_table[filter_table[,9]==1,]
filter_table <- filter_table[filter_table[,10]==1,]
filter_table <- filter_table[filter_table[,11]==1,]
filter_table <- filter_table[filter_table[,12]==1,]
filter_table <- filter_table[filter_table[,13]==1,]
filter_table <- filter_table[filter_table[,14]==1,]
filter_table <- filter_table[filter_table[,17]==1,]
filter_table <- filter_table[filter_table[,18]==1,]
filter_table <- filter_table[filter_table[,19]==1,]
filter_table <- filter_table[filter_table[,20]==1,]
dim(filter_table)
heatmap(as.matrix(filter_table), cexCol = 0.4, cexRow = 0.1)
```

```{r filtering the model with all interaction}
tfilter <- t(filter_table)
tfilter <- tfilter[order(rownames(tfilter)),]
tfilter[,1]
write.table(tfilter,file = './Desktop/Work/Data_analysis/ASP/Data/Th_model_filter.txt', sep = '\t', quote = FALSE)
```

After we perform filter by graph, we then adjust the matrix for futher convertion to BoolNet format.

## Convert models table to BoolNet format

```{r create model list}
model_tab <- list()
for(i in 1:dim(tfilter)[2]){
  model_tab[[i]] <- as.character(names(tfilter[tfilter[,i]==1,i]))
}
for(i in 1:length(model_tab)){
  model_tab[[i]] <- gsub('clause', replacement = '', model_tab[[i]])
  model_tab[[i]] <- gsub('constant', replacement = '', model_tab[[i]])
  model_tab[[i]] <- gsub("(", replacement = '', model_tab[[i]], fixed = TRUE)
  model_tab[[i]] <- gsub(")", replacement = '', model_tab[[i]], fixed = TRUE)
  model_tab[[i]] <- strsplit(model_tab[[i]], split = ',')
}
```

```{r create list of network table}
library(plyr)
model_list <- list()
for(i in 1:length(model_tab)){
  p <- data.frame()
  for(j in 1:length(model_tab[[i]])){
    p <- rbind.fill(p,as.data.frame(t(unlist(model_tab[[i]][j]))))
  }
model_list[[i]] <- p
}
model_list
```

```{r turn network table to BoolNet equations list}
boolnet_list <- list()
for(a in 1:length(model_list)){
  part <- model_list[[a]]
  p <- c()
  q <- c()
  tab_equation <- c()
  for(i in 1:length(summary(part[,1]))){
    spec_tab <- part[part$V1==names(summary(part[,1])[i]),]
    if(is.na(spec_tab$V3[1])==FALSE){
      if(spec_tab$V4[1]==-1){
        p <- paste('!',spec_tab$V3[1],sep = '')
      }
      else{
        p <- as.character(spec_tab$V3[1])
      }
      if(dim(spec_tab)[1]>1){
        for(j in 2:dim(spec_tab)[1]){
          if(spec_tab$V4[j]==-1){
            q <- paste('!',spec_tab$V3[j], sep = '')
          }
          else{
            q <- spec_tab$V3[j]
          }
          if(spec_tab$V2[j]==spec_tab$V2[j-1]){
            p <- paste(p,'&',q,sep='')
          }
          else{
            p <- paste(p,' | ',q, sep = '')
          }
        }
      }
    }
    else{
      p = as.character(spec_tab$V2)
    }
    tab_equation = rbind(tab_equation,p)
  }
  boolnet <- data.frame(names(summary(model_list[[a]][,1])), tab_equation)
  colnames(boolnet) <- c('targets', 'factors')
  rownames(boolnet) <- c()
  boolnet_list[[a]] <- boolnet
}
rm(boolnet)
boolnet_list
```

'boolnet_list' containts a list of boolnet format model, which could be imported to BoolNet and GinSIM for further analysis.

```{r writing boolnet file}
#Pick one model from the list 
write.table(boolnet[[]], 
            file = './Desktop/Work/Data_analysis/ASP/Data/Th_model_test1.txt', 
            sep = ', ', 
            quote = FALSE, 
            row.names = FALSE)
```